# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from typing import Optional

from src.common.dto.pagination_response_dto import PaginationResponseDto
from src.users.dto.user_create_dto import UserCreateDto, UserUpdateRoleDto
from src.users.dto.user_search_dto import UserSearchDto
from src.users.repository.user_repository import UserRepository
from src.users.user_model import UserModel, UserRoleEnum



from fastapi import Depends

class UserService:
    """
    Handles the business logic for user management.
    """

    def __init__(self, user_repo: UserRepository = Depends()):
        self.user_repo = user_repo

    async def create_user_if_not_exists(
        self, email: str, name: str, picture: Optional[str]
    ) -> UserModel:
        """
        Retrieves a user by their email. If the user exists, it returns it.
        If the user doesn't exist, it creates a new user document.
        """

        # 1. Check if the user already exists in the database.
        existing_user = await self.user_repo.get_by_email(email)

        if existing_user:
            return existing_user

        # 2. If the user does not exist, create a new User using UserCreateDto
        #    ID will be auto-generated by the DB
        new_user_dto = UserCreateDto(
            email=email,
            name=name,
            picture=picture or "",
        )
        
        # We need to ensure roles are set, but UserCreateDto doesn't have roles.
        # The repository create method takes a Pydantic model or dict.
        # If we pass UserCreateDto, we miss 'roles'.
        # We can pass a dict that includes roles.
        user_data = new_user_dto.model_dump()
        user_data["roles"] = [UserRoleEnum.USER]

        # 3. Call the repository's create() method
        return await self.user_repo.create(user_data)

    async def get_user_by_id(self, user_id: int) -> Optional[UserModel]:
        """Finds a single user by their ID."""
        return await self.user_repo.get_by_id(user_id)

    async def find_all_users(
        self, search_dto: UserSearchDto
    ) -> PaginationResponseDto[UserModel]:
        """Retrieves a paginated list of all users."""
        return await self.user_repo.query(search_dto)

    async def update_user_role(
        self, user_id: int, role_data: UserUpdateRoleDto
    ) -> Optional[UserModel]:
        """Updates the role of a specific user."""
            
        # Convert the list of enums to a list of strings for DB
        roles_as_strings = [role.value for role in role_data.roles]

        # The update method in the repository would handle updating the 'role' field
        return await self.user_repo.update(user_id, {"roles": roles_as_strings})

    async def delete_user_by_id(self, user_id: int) -> bool:
        """Deletes a user from the system."""
        return await self.user_repo.delete(user_id)

